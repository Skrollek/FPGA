module hex7seg (
    input  logic [3:0] hex,   
    output logic [6:0] seg   
);
    always_comb begin
        case (hex)
            4'h0: seg = ~7'h3F;
            4'h1: seg = ~7'h06;
            4'h2: seg = ~7'h5B;
            4'h3: seg = ~7'h4F;
            4'h4: seg = ~7'h66;
            4'h5: seg = ~7'h6D;
            4'h6: seg = ~7'h7D;
            4'h7: seg = ~7'h07;
            4'h8: seg = ~7'h7F;
            4'h9: seg = ~7'h6F;
            4'hA: seg = ~7'h77;
            4'hB: seg = ~7'h7C;
            4'hC: seg = ~7'h58;
            4'hD: seg = ~7'h5E;
            4'hE: seg = ~7'h79;
            4'hF: seg = ~7'h71;
            default: seg = 7'b0;
        endcase
    end
endmodule

module synchronizer#(parameter N=2)(
	input clk,
	input sig,
	output synsig
);
	reg [N-1:0] buffer;
	assign synsig = buffer[N-1];
	always @(posedge clk)
		buffer <= {buffer[N-2:0], sig};
endmodule

module synchronizers#(parameter M=1, N=2)(
	input clk,
	input [M-1:0] sig,
	output [M-1:0] outsig
);
	genvar k;
	generate
		for (k = 0; k < M; k = k+1) begin : blk
		synchronizer#(N) syn(clk, sig[k], outsig[k]);
		end
	endgenerate
endmodule

module memory(input clk,
              input load,
              input  [9:0] addr,
              input  [7:0] data_in,
              output logic [7:0] data_out);
  logic [7:0] mem [1023 : 0];
  always_ff @(posedge clk) begin
    if(load) mem[addr] <= data_in;
    data_out <= mem[addr];
  end
endmodule

module ctrl_mem(
  input  clk,
  input  [9:0] SW,
  input  [3:0] KEY,
  output [6:0] HEX0,
  output [6:0] HEX1,
  output [6:0] HEX2,
  output [6:0] HEX3,
  output [6:0] HEX4,
  output [6:0] HEX5,
  output [9:0] LEDR
);
  localparam IDLE = 2'b00;
  localparam ADD  = 2'b01;
  localparam SUB  = 2'b10;
  localparam LOAD = 2'b11;
  logic [1:0] state_prev;
  logic [1:0] state_curr;
  
  logic [9:0] curr_addr;
  logic [9:0] curr_addr_next;
  logic [7:0] curr_data;
  hex7seg h0(curr_addr[3:0], HEX0);
  hex7seg h1(curr_addr[7:4], HEX1);
  assign LEDR[9:8] = curr_addr[9:8];
  hex7seg h2(curr_data[3:0], HEX2);
  hex7seg h3(curr_data[7:4], HEX3);
  assign LEDR[7:0] = curr_data;
  hex7seg h4(SW[3:0],HEX4);
  hex7seg h5(SW[7:4],HEX5);
  
  logic [3:0] key_sync;
  synchronizers #(.M(4), .N(4)) syncs0 (clk, ~KEY, key_sync);
  
  assign curr_addr_next = state_curr == IDLE && state_prev == ADD  ? curr_addr + 10'b1 : 
                          state_curr == IDLE && state_prev == SUB  ? curr_addr - 10'b1 :
                          state_curr == IDLE && state_prev == LOAD ? SW : curr_addr;
  
  
  memory m1(clk, key_sync[3], curr_addr, SW[7:0], curr_data);	
  always_ff @(posedge clk) begin
    curr_addr <= curr_addr_next;
  end
  

  always_ff @(posedge clk) begin
    if(key_sync[0]) state_curr <= ADD;
    else if (key_sync[1]) state_curr <= SUB;
    else if (key_sync[2]) state_curr <= LOAD;
    else state_curr <= IDLE;
  end
  always_ff @(posedge clk) begin
    state_prev <= state_curr;
  end
                     
  
endmodule

module FirstDE1Project(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


//=======================================================
//  Structural coding
//=======================================================
ctrl_mem (CLOCK2_50, SW, KEY, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, LEDR); 

endmodule