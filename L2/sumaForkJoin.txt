`timescale 1ns/1ps

module suma_tablicy_fork_join #(
    parameter N = 8, 
    parameter WIDTH = 8, 
    parameter SUM_WIDTH = WIDTH + $clog2(N)
) ();

    reg [WIDTH-1:0] mem [0:N-1];
    reg [SUM_WIDTH-1:0] sum_tree [1:2*N-1];

    task automatic compute_node(input integer k);
        integer left, right;
        begin
            if (k >= N) begin
                sum_tree[k] = mem[k - N];
            end else begin
                left  = 2*k;
                right = 2*k + 1;

                fork
                    compute_node(left);
                    compute_node(right);
                join

                sum_tree[k] = sum_tree[left] + sum_tree[right];
            end
        end
    endtask


    initial begin
        integer i;
        integer golden;

        for (i = 0; i < N; i = i + 1) begin
            mem[i] = i + 1; 
        end

        for (i = 1; i < 2*N; i = i + 1)
            sum_tree[i] = 0;

        $display("Start obliczen. N = %0d, WIDTH = %0d, SUM_WIDTH = %0d", N, WIDTH, SUM_WIDTH);

        compute_node(1);

        $display("Suma wszystkich elementow = %0d", sum_tree[1]);

        golden = 0;
        for (i = 0; i < N; i = i + 1)
            golden = golden + mem[i];
        $display("Golden (sekwencyjnie) = %0d", golden);

        if (golden !== sum_tree[1])
            $display("UWAGA: Rozne wyniki!\n");
        else
            $display("Wynik poprawny.\n");

        $finish;
    end
endmodule

module tb;
    suma_tablicy_fork_join #(.N(8)) dut ();
endmodule